import { Request, Response } from 'express';
import { SupabaseService } from '../services/supabase.service';
import { databaseLogger } from '../services/database-logger.service';
import logger from '../utils/logger';

interface SurveyAnswer {
  user_survey_id: string;
  question_id: string;
  model_id: string;
  answer: any;
}

interface SurveyQuestion {
  id: string;
  model_id: string;
  question_code: string;
  type: 'single' | 'multiple' | 'scale' | 'text' | 'sorting';
}

interface SortingAnswer {
  order?: number[];
}

export class AnswerController {
  private supabaseService: SupabaseService;

  constructor() {
    this.supabaseService = SupabaseService.getInstance();
  }

  // Êèê‰∫§Á≠îÊ°à - Â∏¶‰∫ãÂä°ÊéßÂà∂
  async submitAnswers(req: Request, res: Response) {
    const transactionId = databaseLogger.logTransaction('start');
    const startTime = Date.now();
    
    try {
      const data = req.body;

      // È™åËØÅÊï∞ÊçÆÂÆåÊï¥ÊÄß
      const testTypeInfo = {
        userInfo: { 
          present: !!data.userInfo, 
          pageName: 'Áî®Êà∑‰ø°ÊÅØÈ°µÈù¢', 
          description: 'Âü∫Êú¨‰∏™‰∫∫‰ø°ÊÅØÂ°´ÂÜô',
          requiredFields: ['name', 'gender', 'age', 'city', 'occupation', 'education']
        },
        fiveQuestions: { 
          present: !!data.fiveQuestions, 
          pageName: '‰∫îÈóÆÊ≥ïÊµãËØïÈ°µÈù¢', 
          description: 'ËÅå‰∏öÂèëÂ±ï‰∫îÈóÆÊ≥ïÊµãËØï',
          expectedAnswers: 2
        },
        mbti: { 
          present: !!data.mbti, 
          pageName: 'MBTI‰∫∫Ê†ºÊµãËØïÈ°µÈù¢', 
          description: 'MBTIÂçÅÂÖ≠Âûã‰∫∫Ê†ºÊµãËØï',
          expectedAnswers: 8
        },
        bigFive: { 
          present: !!data.bigFive, 
          pageName: '‰∫îÂ§ß‰∫∫Ê†ºÊµãËØïÈ°µÈù¢', 
          description: 'Â§ß‰∫î‰∫∫Ê†ºÁâπË¥®ÊµãËØï',
          expectedAnswers: 10
        },
        disc: { 
          present: !!data.disc, 
          pageName: 'DISCË°å‰∏∫ÊµãËØïÈ°µÈù¢', 
          description: 'DISCË°å‰∏∫È£éÊ†ºÊµãËØï',
          expectedAnswers: 8
        },
        holland: { 
          present: !!data.holland, 
          pageName: 'ÈúçÂÖ∞Âæ∑ÊµãËØïÈ°µÈù¢', 
          description: 'ÈúçÂÖ∞Âæ∑ËÅå‰∏öÂÖ¥Ë∂£ÊµãËØï',
          expectedAnswers: 18
        },
        values: { 
          present: !!data.values, 
          pageName: '‰ª∑ÂÄºËßÇÊµãËØïÈ°µÈù¢', 
          description: 'ËÅå‰∏ö‰ª∑ÂÄºËßÇËØÑ‰º∞ÊµãËØï',
          expectedAnswers: 6
        }
      };

      const missingTests = Object.entries(testTypeInfo)
        .filter(([_, info]) => !info.present)
        .map(([key, info]) => ({
          testType: key,
          pageName: info.pageName,
          description: info.description,
          fieldName: key
        }));

      if (missingTests.length > 0) {
        const detailedMissingInfo = {
          totalMissing: missingTests.length,
          totalRequired: 7,
          missingTests: missingTests,
          presentTests: Object.entries(testTypeInfo)
            .filter(([_, info]) => info.present)
            .map(([key, info]) => ({
              testType: key,
              pageName: info.pageName,
              answerCount: data[key] ? Object.keys(data[key]).length : 0
            })),
          frontendGuidance: {
            message: 'ËØ∑ÂÆåÊàê‰ª•‰∏ãÊµãËØïÈ°µÈù¢',
            missingPages: missingTests.map(test => test.pageName),
            nextAction: 'ËØ∑ËøîÂõûÂØπÂ∫îÈ°µÈù¢ÂÆåÊàêÊµãËØïÂêéÈáçÊñ∞Êèê‰∫§'
          }
        };

        logger.warn('‚ùå Á≠îÊ°àÊèê‰∫§Â§±Ë¥•ÔºöÊï∞ÊçÆ‰∏çÂÆåÊï¥', { 
          missingFields: Object.fromEntries(
            Object.entries(testTypeInfo).map(([key, info]) => [key, !info.present])
          ),
          detailedValidation: detailedMissingInfo,
          inputParams: {
            originalRequest: {
              bodyKeys: Object.keys(data),
              hasUserInfo: !!data.userInfo,
              userInfoDetails: data.userInfo ? {
                hasRequiredFields: !!(data.userInfo.name && data.userInfo.gender && data.userInfo.age && 
                                     data.userInfo.city && data.userInfo.occupation && data.userInfo.education),
                presentFields: Object.keys(data.userInfo),
                missingUserInfoFields: ['name', 'gender', 'age', 'city', 'occupation', 'education']
                  .filter(field => !data.userInfo[field])
              } : { error: 'userInfoÂØπË±°Áº∫Â§±' },
              testAnswerCounts: Object.fromEntries(
                Object.entries(testTypeInfo).map(([key, _]) => [
                  key, 
                  data[key] ? Object.keys(data[key]).length : 0
                ])
              )
            }
          }
        });

        logger.error('üéØ ÂâçÁ´ØÂ§ÑÁêÜÊåáÂçóÔºöÁº∫Â§±Â≠óÊÆµËØ¶ÊÉÖ', {
          summary: `Áº∫Â§± ${missingTests.length} ‰∏™ÊµãËØïÔºåËøòÈúÄÂÆåÊàê ${missingTests.map(t => t.pageName).join('„ÄÅ')}`,
          missingPagesDetail: missingTests.map(test => ({
            È°µÈù¢ÂêçÁß∞: test.pageName,
            ÊµãËØïÊèèËø∞: test.description,
            Â≠óÊÆµÂêçÁß∞: test.fieldName,
            ÂâçÁ´ØË∑ØÁî±Âª∫ËÆÆ: `/${test.testType}`,
            Áî®Êà∑ÊèêÁ§∫: `ËØ∑ÂÆåÊàê${test.description}`
          })),
          completedPages: Object.entries(testTypeInfo)
            .filter(([_, info]) => info.present)
            .map(([key, info]) => ({
              È°µÈù¢ÂêçÁß∞: info.pageName,
              Á≠îÈ¢òÊï∞Èáè: data[key] ? Object.keys(data[key]).length : 0,
              Áä∂ÊÄÅ: '‚úÖ Â∑≤ÂÆåÊàê'
            })),
          actionRequired: {
            ÂâçÁ´ØÊòæÁ§∫Ê∂àÊÅØ: `ËØ∑ÂÆåÊàêÂâ©‰Ωô ${missingTests.length} ‰∏™ÊµãËØïÔºö${missingTests.map(t => t.description).join('„ÄÅ')}`,
            Âª∫ËÆÆË∑≥ËΩ¨È°µÈù¢: missingTests[0]?.pageName || 'È¶ñÈ°µ',
            ÈîôËØØÁ∫ßÂà´: 'validation_error'
          }
        });

        return res.status(400).json({
          error: 'Êï∞ÊçÆ‰∏çÂÆåÊï¥ÔºåËØ∑Á°Æ‰øùÊâÄÊúâÊµãËØïÈÉΩÂ∑≤ÂÆåÊàê',
          code: 'INCOMPLETE_DATA',
          details: {
            message: `ËØ∑ÂÆåÊàêÂâ©‰Ωô ${missingTests.length} ‰∏™ÊµãËØï`,
            missingTests: missingTests.map(test => ({
              name: test.description,
              page: test.pageName,
              field: test.testType
            })),
            completedCount: 7 - missingTests.length,
            totalRequired: 7,
            nextStep: `ËØ∑ËøîÂõû${missingTests[0]?.pageName || 'Áõ∏Â∫îÈ°µÈù¢'}ÂÆåÊàêÊµãËØï`
          }
        });
      }

      const client = this.supabaseService.getClient();
      
      // ÂºÄÂßã‰∫ãÂä°Êó•Âøó
      logger.info('üîÑ ÂºÄÂßãÁ≠îÊ°àÊèê‰∫§‰∫ãÂä°', {
        transactionId,
        userInfo: {
          name: data.userInfo.name,
          questionsCount: {
            fiveQuestions: Object.keys(data.fiveQuestions || {}).length,
            mbti: Object.keys(data.mbti || {}).length,
            bigFive: Object.keys(data.bigFive || {}).length,
            disc: Object.keys(data.disc || {}).length,
            holland: Object.keys(data.holland || {}).length,
            values: Object.keys(data.values || {}).length
          }
        },
        inputParams: {
          originalRequest: {
            hasUserInfo: !!data.userInfo,
            userInfoFields: data.userInfo ? Object.keys(data.userInfo) : [],
            testTypesPresent: {
              fiveQuestions: !!data.fiveQuestions,
              mbti: !!data.mbti,
              bigFive: !!data.bigFive,
              disc: !!data.disc,
              holland: !!data.holland,
              values: !!data.values
            },
            totalQuestionAnswers: [
              data.fiveQuestions ? Object.keys(data.fiveQuestions).length : 0,
              data.mbti ? Object.keys(data.mbti).length : 0,
              data.bigFive ? Object.keys(data.bigFive).length : 0,
              data.disc ? Object.keys(data.disc).length : 0,
              data.holland ? Object.keys(data.holland).length : 0,
              data.values ? Object.keys(data.values).length : 0
            ].reduce((a, b) => a + b, 0)
          },
          validation: {
            userInfoValidation: {
              hasRequiredFields: !!(data.userInfo?.name && data.userInfo?.gender && data.userInfo?.age && 
                                   data.userInfo?.city && data.userInfo?.occupation && data.userInfo?.education),
              fieldTypes: data.userInfo ? {
                name: typeof data.userInfo.name,
                gender: typeof data.userInfo.gender,
                age: typeof data.userInfo.age,
                city: typeof data.userInfo.city,
                occupation: typeof data.userInfo.occupation,
                education: typeof data.userInfo.education,
                phone: typeof data.userInfo.phone
              } : {}
            }
          }
        }
      });

      // 1. ‰øùÂ≠òÁî®Êà∑Âü∫Êú¨‰ø°ÊÅØ
      const userQueryId = databaseLogger.logQueryStart({
        table: 'user_survey',
        operation: 'INSERT',
        data: data.userInfo,
        inputParams: {
          transactionId,
          step: '1_save_user_info',
          originalUserInfo: data.userInfo,
          processedUserInfo: {
            name: data.userInfo.name,
            gender: data.userInfo.gender,
            age: data.userInfo.age,
            city: data.userInfo.city,
            occupation: data.userInfo.occupation,
            education: data.userInfo.education,
            phone: data.userInfo.phone,
          }
        }
      });

      const { data: userData, error: userError } = await client
        .from('user_survey')
        .insert({
          name: data.userInfo.name,
          gender: data.userInfo.gender,
          age: data.userInfo.age,
          city: data.userInfo.city,
          occupation: data.userInfo.occupation,
          education: data.userInfo.education,
          phone: data.userInfo.phone,
        })
        .select()
        .single();

      if (userError || !userData) {
        databaseLogger.logQueryError(userQueryId, userError, startTime, {
          table: 'user_survey',
          operation: 'INSERT'
        });
        databaseLogger.logTransaction('rollback', transactionId);
        throw new Error(`Áî®Êà∑‰ø°ÊÅØ‰øùÂ≠òÂ§±Ë¥•: ${userError?.message}`);
      }

      databaseLogger.logQuerySuccess(userQueryId, userData, Date.now(), {
        table: 'user_survey',
        operation: 'INSERT',
        inputParams: {
          transactionId,
          step: '1_save_user_info',
          insertedUserId: userData.id,
          insertedUserName: userData.name
        }
      });

      const userId = userData.id;
      logger.info('‚úÖ Áî®Êà∑‰ø°ÊÅØ‰øùÂ≠òÊàêÂäü', { userId, transactionId });

      // 2. Ëé∑ÂèñÊâÄÊúâÊ®°Âûã‰ø°ÊÅØ
      const modelsQueryId = databaseLogger.logQueryStart({
        table: 'survey_model',
        operation: 'SELECT'
      });

      const { data: modelsData, error: modelsError } = await client
        .from('survey_model')
        .select('*')
        .in('code', ['fiveq', 'mbti', 'big5', 'disc', 'holland', 'motivation']);

      if (modelsError || !modelsData) {
        databaseLogger.logQueryError(modelsQueryId, modelsError, Date.now(), {
          table: 'survey_model',
          operation: 'SELECT'
        });
        databaseLogger.logTransaction('rollback', transactionId);
        throw new Error(`Ëé∑ÂèñÊ®°Âûã‰ø°ÊÅØÂ§±Ë¥•: ${modelsError?.message}`);
      }

      databaseLogger.logQuerySuccess(modelsQueryId, modelsData, Date.now(), {
        table: 'survey_model',
        operation: 'SELECT'
      });

      // 3. Ëé∑ÂèñÊâÄÊúâÈ¢òÁõÆ‰ø°ÊÅØ
      const modelIds = modelsData.map((model: any) => model.id);
      const questionsQueryId = databaseLogger.logQueryStart({
        table: 'survey_question',
        operation: 'SELECT',
        filters: { model_id: modelIds }
      });

      const { data: questionsData, error: questionsError } = await client
        .from('survey_question')
        .select('*')
        .in('model_id', modelIds);

      if (questionsError || !questionsData) {
        databaseLogger.logQueryError(questionsQueryId, questionsError, Date.now(), {
          table: 'survey_question',
          operation: 'SELECT'
        });
        databaseLogger.logTransaction('rollback', transactionId);
        throw new Error(`Ëé∑ÂèñÈ¢òÁõÆ‰ø°ÊÅØÂ§±Ë¥•: ${questionsError?.message}`);
      }

      databaseLogger.logQuerySuccess(questionsQueryId, questionsData, Date.now(), {
        table: 'survey_question',
        operation: 'SELECT'
      });

      // 4. ÂáÜÂ§áÁ≠îÊ°àÊï∞ÊçÆ
      const answers: any[] = [];
      const answerStats = {
        fiveq: 0, mbti: 0, big5: 0, disc: 0, holland: 0, motivation: 0
      };

      // Â§ÑÁêÜÂêÑ‰∏™ÊµãËØïÁ±ªÂûãÁöÑÁ≠îÊ°à
      const testTypes = [
        { key: 'fiveQuestions', code: 'fiveq', data: data.fiveQuestions },
        { key: 'mbti', code: 'mbti', data: data.mbti },
        { key: 'bigFive', code: 'big5', data: data.bigFive },
        { key: 'disc', code: 'disc', data: data.disc },
        { key: 'holland', code: 'holland', data: data.holland },
        { key: 'values', code: 'motivation', data: data.values }
      ];

      for (const testType of testTypes) {
        const model = modelsData.find((m: any) => m.code === testType.code);
        if (model && testType.data) {
          Object.entries(testType.data).forEach(([questionCode, answer]) => {
            const question = questionsData.find((q: any) => 
              q.model_id === model.id && q.question_code === questionCode
            );
            
            if (question) {
              // Â§ÑÁêÜÊéíÂ∫èÈ¢òÁöÑÈªòËÆ§ÂÄº
              if (question.type === 'sorting' && (!answer || !(answer as SortingAnswer).order)) {
                answer = { order: [1, 2, 3, 4, 5] };
              }
              
              answers.push({
                user_survey_id: userId,
                question_id: question.id,
                model_id: model.id,
                answer: answer
              });
              
              answerStats[testType.code as keyof typeof answerStats]++;
            }
          });
        }
      }

      logger.info('üìä Á≠îÊ°àÊï∞ÊçÆÂáÜÂ§áÂÆåÊàê', {
        transactionId,
        totalAnswers: answers.length,
        byType: answerStats
      });

      // 5. ÊâπÈáè‰øùÂ≠òÁ≠îÊ°à - ‰ΩøÁî®‰∫ãÂä°
      if (answers.length > 0) {
        const answersQueryId = databaseLogger.logQueryStart({
          table: 'user_survey_answer',
          operation: 'INSERT_BATCH',
          data: { count: answers.length }
        });

        const { data: answersData, error: answersError } = await client
          .from('user_survey_answer')
          .insert(answers)
          .select();

        if (answersError) {
          databaseLogger.logQueryError(answersQueryId, answersError, Date.now(), {
            table: 'user_survey_answer',
            operation: 'INSERT_BATCH'
          });
          databaseLogger.logTransaction('rollback', transactionId);
          
          // Â∞ùËØïÂà†Èô§Â∑≤‰øùÂ≠òÁöÑÁî®Êà∑‰ø°ÊÅØÔºàÂõûÊªöÔºâ
          await client.from('user_survey').delete().eq('id', userId);
          
          throw new Error(`Á≠îÊ°à‰øùÂ≠òÂ§±Ë¥•: ${answersError.message}`);
        }

        databaseLogger.logQuerySuccess(answersQueryId, answersData, Date.now(), {
          table: 'user_survey_answer',
          operation: 'INSERT_BATCH'
        });
      }

      // ‰∫ãÂä°ÂÆåÊàê
      databaseLogger.logTransaction('commit', transactionId);
      const duration = Date.now() - startTime;

      logger.info('üéâ Á≠îÊ°àÊèê‰∫§‰∫ãÂä°ÂÆåÊàê', {
        transactionId,
        userId,
        totalAnswers: answers.length,
        duration: `${duration}ms`,
        success: true
      });

      // ËøîÂõûÊàêÂäüÂìçÂ∫î
      res.json({
        message: 'ÊµãËØïÁªìÊûú‰øùÂ≠òÊàêÂäü',
        surveyId: userId,
        stats: {
          totalAnswers: answers.length,
          answersByType: answerStats,
          duration: `${duration}ms`
        }
      });

    } catch (error) {
      const duration = Date.now() - startTime;
      
      // ËÆ∞ÂΩï‰∫ãÂä°Â§±Ë¥•
      databaseLogger.logTransaction('rollback', transactionId);
      
      logger.error('‚ùå Á≠îÊ°àÊèê‰∫§‰∫ãÂä°Â§±Ë¥•', {
        transactionId,
        error: {
          name: error instanceof Error ? error.name : 'Unknown',
          message: error instanceof Error ? error.message : String(error),
          stack: error instanceof Error ? error.stack : undefined
        },
        duration: `${duration}ms`
      });

      res.status(500).json({
        error: error instanceof Error ? error.message : 'Â§ÑÁêÜÊµãËØïÊèê‰∫§Â§±Ë¥•',
        transactionId
      });
    }
  }
} 