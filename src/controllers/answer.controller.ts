import { Request, Response } from 'express';
import { SupabaseService } from '../services/supabase.service';
import { databaseLogger } from '../services/database-logger.service';
import { AIEnhancedAnalysisService } from '../services/ai-enhanced-analysis.service';
import { AnalysisRequest } from '../services/auto-analysis.service';
import logger from '../utils/logger';

interface SurveyAnswer {
  user_survey_id: string;
  question_id: string;
  model_id: string;
  answer: any;
}

interface SurveyQuestion {
  id: string;
  model_id: string;
  question_code: string;
  type: 'single' | 'multiple' | 'scale' | 'text' | 'sorting';
}

interface SortingAnswer {
  order: number[];
}

export class AnswerController {
  private supabaseService: SupabaseService;
  private aiAnalysisService: AIEnhancedAnalysisService;

  constructor() {
    this.supabaseService = SupabaseService.getInstance();
    this.aiAnalysisService = new AIEnhancedAnalysisService();
  }

  // Êèê‰∫§Á≠îÊ°à - Â∏¶‰∫ãÂä°ÊéßÂà∂ÂíåËá™Âä®ÂàÜÊûê
  async submitAnswers(req: Request, res: Response) {
    const transactionId = databaseLogger.logTransaction('start');
    const startTime = Date.now();
    
    try {
      const data = req.body;

      // È™åËØÅÊï∞ÊçÆÂÆåÊï¥ÊÄß
      const testTypeInfo = {
        userInfo: { 
          present: !!data.userInfo, 
          pageName: 'Áî®Êà∑‰ø°ÊÅØÈ°µÈù¢', 
          description: 'Âü∫Êú¨‰∏™‰∫∫‰ø°ÊÅØÂ°´ÂÜô',
          requiredFields: ['name', 'gender', 'age', 'city', 'occupation', 'education']
        },
        fiveQuestions: { 
          present: !!data.fiveQuestions, 
          pageName: '‰∫îÈóÆÊ≥ïÊµãËØïÈ°µÈù¢', 
          description: 'ËÅå‰∏öÂèëÂ±ï‰∫îÈóÆÊ≥ïÊµãËØï',
          expectedAnswers: 2
        },
        mbti: { 
          present: !!data.mbti, 
          pageName: 'MBTI‰∫∫Ê†ºÊµãËØïÈ°µÈù¢', 
          description: 'MBTIÂçÅÂÖ≠Âûã‰∫∫Ê†ºÊµãËØï',
          expectedAnswers: 8
        },
        bigFive: { 
          present: !!data.bigFive, 
          pageName: '‰∫îÂ§ß‰∫∫Ê†ºÊµãËØïÈ°µÈù¢', 
          description: 'Â§ß‰∫î‰∫∫Ê†ºÁâπË¥®ÊµãËØï',
          expectedAnswers: 10
        },
        disc: { 
          present: !!data.disc, 
          pageName: 'DISCË°å‰∏∫ÊµãËØïÈ°µÈù¢', 
          description: 'DISCË°å‰∏∫È£éÊ†ºÊµãËØï',
          expectedAnswers: 8
        },
        holland: { 
          present: !!data.holland, 
          pageName: 'ÈúçÂÖ∞Âæ∑ÊµãËØïÈ°µÈù¢', 
          description: 'ÈúçÂÖ∞Âæ∑ËÅå‰∏öÂÖ¥Ë∂£ÊµãËØï',
          expectedAnswers: 18
        },
        values: { 
          present: !!data.values, 
          pageName: '‰ª∑ÂÄºËßÇÊµãËØïÈ°µÈù¢', 
          description: 'ËÅå‰∏ö‰ª∑ÂÄºËßÇËØÑ‰º∞ÊµãËØï',
          expectedAnswers: 6
        }
      };

      const missingTests = Object.entries(testTypeInfo)
        .filter(([_, info]) => !info.present)
        .map(([key, info]) => ({
          testType: key,
          pageName: info.pageName,
          description: info.description,
          fieldName: key
        }));

      if (missingTests.length > 0) {
        const detailedMissingInfo = {
          totalMissing: missingTests.length,
          totalRequired: 7,
          missingTests: missingTests,
          presentTests: Object.entries(testTypeInfo)
            .filter(([_, info]) => info.present)
            .map(([key, info]) => ({
              testType: key,
              pageName: info.pageName,
              answerCount: data[key] ? Object.keys(data[key]).length : 0
            })),
          frontendGuidance: {
            message: 'ËØ∑ÂÆåÊàê‰ª•‰∏ãÊµãËØïÈ°µÈù¢',
            missingPages: missingTests.map(test => test.pageName),
            nextAction: 'ËØ∑ËøîÂõûÂØπÂ∫îÈ°µÈù¢ÂÆåÊàêÊµãËØïÂêéÈáçÊñ∞Êèê‰∫§'
          }
        };

        logger.warn('‚ùå Á≠îÊ°àÊèê‰∫§Â§±Ë¥•ÔºöÊï∞ÊçÆ‰∏çÂÆåÊï¥', { 
          missingFields: Object.fromEntries(
            Object.entries(testTypeInfo).map(([key, info]) => [key, !info.present])
          ),
          detailedValidation: detailedMissingInfo,
          inputParams: {
            originalRequest: {
              bodyKeys: Object.keys(data),
              hasUserInfo: !!data.userInfo,
              userInfoDetails: data.userInfo ? {
                hasRequiredFields: !!(data.userInfo.name && data.userInfo.gender && data.userInfo.age && 
                                     data.userInfo.city && data.userInfo.occupation && data.userInfo.education),
                presentFields: Object.keys(data.userInfo),
                missingUserInfoFields: ['name', 'gender', 'age', 'city', 'occupation', 'education']
                  .filter(field => !data.userInfo[field])
              } : { error: 'userInfoÂØπË±°Áº∫Â§±' },
              testAnswerCounts: Object.fromEntries(
                Object.entries(testTypeInfo).map(([key, _]) => [
                  key, 
                  data[key] ? Object.keys(data[key]).length : 0
                ])
              )
            }
          }
        });

        logger.error('üéØ ÂâçÁ´ØÂ§ÑÁêÜÊåáÂçóÔºöÁº∫Â§±Â≠óÊÆµËØ¶ÊÉÖ', {
          summary: `Áº∫Â§± ${missingTests.length} ‰∏™ÊµãËØïÔºåËøòÈúÄÂÆåÊàê ${missingTests.map(t => t.pageName).join('„ÄÅ')}`,
          missingPagesDetail: missingTests.map(test => ({
            È°µÈù¢ÂêçÁß∞: test.pageName,
            ÊµãËØïÊèèËø∞: test.description,
            Â≠óÊÆµÂêçÁß∞: test.fieldName,
            ÂâçÁ´ØË∑ØÁî±Âª∫ËÆÆ: `/${test.testType}`,
            Áî®Êà∑ÊèêÁ§∫: `ËØ∑ÂÆåÊàê${test.description}`
          })),
          completedPages: Object.entries(testTypeInfo)
            .filter(([_, info]) => info.present)
            .map(([key, info]) => ({
              È°µÈù¢ÂêçÁß∞: info.pageName,
              Á≠îÈ¢òÊï∞Èáè: data[key] ? Object.keys(data[key]).length : 0,
              Áä∂ÊÄÅ: '‚úÖ Â∑≤ÂÆåÊàê'
            })),
          actionRequired: {
            ÂâçÁ´ØÊòæÁ§∫Ê∂àÊÅØ: `ËØ∑ÂÆåÊàêÂâ©‰Ωô ${missingTests.length} ‰∏™ÊµãËØïÔºö${missingTests.map(t => t.description).join('„ÄÅ')}`,
            Âª∫ËÆÆË∑≥ËΩ¨È°µÈù¢: missingTests[0]?.pageName || 'È¶ñÈ°µ',
            ÈîôËØØÁ∫ßÂà´: 'validation_error'
          }
        });

        return res.status(400).json({
          error: 'Êï∞ÊçÆ‰∏çÂÆåÊï¥ÔºåËØ∑Á°Æ‰øùÊâÄÊúâÊµãËØïÈÉΩÂ∑≤ÂÆåÊàê',
          code: 'INCOMPLETE_DATA',
          details: {
            message: `ËØ∑ÂÆåÊàêÂâ©‰Ωô ${missingTests.length} ‰∏™ÊµãËØï`,
            missingTests: missingTests.map(test => ({
              name: test.description,
              page: test.pageName,
              field: test.testType
            })),
            completedCount: 7 - missingTests.length,
            totalRequired: 7,
            nextStep: `ËØ∑ËøîÂõû${missingTests[0]?.pageName || 'Áõ∏Â∫îÈ°µÈù¢'}ÂÆåÊàêÊµãËØï`
          }
        });
      }

      const client = this.supabaseService.getClient();
      
      // ÂºÄÂßã‰∫ãÂä°Êó•Âøó
      logger.info('üîÑ ÂºÄÂßãÁ≠îÊ°àÊèê‰∫§‰∫ãÂä°', {
        transactionId,
        userInfo: {
          name: data.userInfo.name,
          questionsCount: {
            fiveQuestions: Object.keys(data.fiveQuestions || {}).length,
            mbti: Object.keys(data.mbti || {}).length,
            bigFive: Object.keys(data.bigFive || {}).length,
            disc: Object.keys(data.disc || {}).length,
            holland: Object.keys(data.holland || {}).length,
            values: Object.keys(data.values || {}).length
          }
        },
        inputParams: {
          originalRequest: {
            hasUserInfo: !!data.userInfo,
            userInfoFields: data.userInfo ? Object.keys(data.userInfo) : [],
            testTypesPresent: {
              fiveQuestions: !!data.fiveQuestions,
              mbti: !!data.mbti,
              bigFive: !!data.bigFive,
              disc: !!data.disc,
              holland: !!data.holland,
              values: !!data.values
            },
            totalQuestionAnswers: [
              data.fiveQuestions ? Object.keys(data.fiveQuestions).length : 0,
              data.mbti ? Object.keys(data.mbti).length : 0,
              data.bigFive ? Object.keys(data.bigFive).length : 0,
              data.disc ? Object.keys(data.disc).length : 0,
              data.holland ? Object.keys(data.holland).length : 0,
              data.values ? Object.keys(data.values).length : 0
            ].reduce((a, b) => a + b, 0)
          },
          validation: {
            userInfoValidation: {
              hasRequiredFields: !!(data.userInfo?.name && data.userInfo?.gender && data.userInfo?.age && 
                                   data.userInfo?.city && data.userInfo?.occupation && data.userInfo?.education),
              fieldTypes: data.userInfo ? {
                name: typeof data.userInfo.name,
                gender: typeof data.userInfo.gender,
                age: typeof data.userInfo.age,
                city: typeof data.userInfo.city,
                occupation: typeof data.userInfo.occupation,
                education: typeof data.userInfo.education,
                phone: typeof data.userInfo.phone
              } : {}
            }
          }
        }
      });

      // 1. ‰øùÂ≠òÁî®Êà∑Âü∫Á°Ä‰ø°ÊÅØ
      const userQueryId = databaseLogger.logQueryStart({
        table: 'user_survey',
        operation: 'INSERT',
        data: data.userInfo
      });

      const { data: userData, error: userError } = await client
        .from('user_survey')
        .insert({
          name: data.userInfo.name,
          gender: data.userInfo.gender,
          age: data.userInfo.age,
          city: data.userInfo.city,
          occupation: data.userInfo.occupation,
          education: data.userInfo.education,
          phone: data.userInfo.phone || null
        })
        .select()
        .single();

      if (userError || !userData) {
        databaseLogger.logQueryError(userQueryId, userError, Date.now(), {
          table: 'user_survey',
          operation: 'INSERT'
        });
        databaseLogger.logTransaction('rollback', transactionId);
        throw new Error(`‰øùÂ≠òÁî®Êà∑‰ø°ÊÅØÂ§±Ë¥•: ${userError?.message}`);
      }

      databaseLogger.logQuerySuccess(userQueryId, userData, Date.now(), {
        table: 'user_survey',
        operation: 'INSERT'
      });

      const userId = userData.id;

      // 2. Ëé∑ÂèñÊâÄÊúâÊ®°Âûã‰ø°ÊÅØ
      const modelsQueryId = databaseLogger.logQueryStart({
        table: 'survey_model',
        operation: 'SELECT'
      });

      const { data: modelsData, error: modelsError } = await client
        .from('survey_model')
        .select('*');

      if (modelsError || !modelsData) {
        databaseLogger.logQueryError(modelsQueryId, modelsError, Date.now(), {
          table: 'survey_model',
          operation: 'SELECT'
        });
        databaseLogger.logTransaction('rollback', transactionId);
        throw new Error(`Ëé∑ÂèñÊ®°Âûã‰ø°ÊÅØÂ§±Ë¥•: ${modelsError?.message}`);
      }

      databaseLogger.logQuerySuccess(modelsQueryId, modelsData, Date.now(), {
        table: 'survey_model',
        operation: 'SELECT'
      });

      // 3. Ëé∑ÂèñÊâÄÊúâÈ¢òÁõÆ‰ø°ÊÅØ
      const modelIds = modelsData.map((model: any) => model.id);
      const questionsQueryId = databaseLogger.logQueryStart({
        table: 'survey_question',
        operation: 'SELECT',
        filters: { model_id: modelIds }
      });

      const { data: questionsData, error: questionsError } = await client
        .from('survey_question')
        .select('*')
        .in('model_id', modelIds);

      if (questionsError || !questionsData) {
        databaseLogger.logQueryError(questionsQueryId, questionsError, Date.now(), {
          table: 'survey_question',
          operation: 'SELECT'
        });
        databaseLogger.logTransaction('rollback', transactionId);
        throw new Error(`Ëé∑ÂèñÈ¢òÁõÆ‰ø°ÊÅØÂ§±Ë¥•: ${questionsError?.message}`);
      }

      databaseLogger.logQuerySuccess(questionsQueryId, questionsData, Date.now(), {
        table: 'survey_question',
        operation: 'SELECT'
      });

      // 4. ÂáÜÂ§áÁ≠îÊ°àÊï∞ÊçÆ
      const answers: any[] = [];
      const answerStats = {
        fiveq: 0, mbti: 0, big5: 0, disc: 0, holland: 0, motivation: 0
      };

      // Â§ÑÁêÜÂêÑ‰∏™ÊµãËØïÁ±ªÂûãÁöÑÁ≠îÊ°à
      const testTypes = [
        { key: 'fiveQuestions', code: 'fiveq', data: data.fiveQuestions },
        { key: 'mbti', code: 'mbti', data: data.mbti },
        { key: 'bigFive', code: 'big5', data: data.bigFive },
        { key: 'disc', code: 'disc', data: data.disc },
        { key: 'holland', code: 'holland', data: data.holland },
        { key: 'values', code: 'motivation', data: data.values }
      ];

      for (const testType of testTypes) {
        const model = modelsData.find((m: any) => m.code === testType.code);
        if (model && testType.data) {
          Object.entries(testType.data).forEach(([questionCode, answer]) => {
            const question = questionsData.find((q: any) => 
              q.model_id === model.id && q.question_code === questionCode
            );
            
            if (question) {
              // Â§ÑÁêÜÊéíÂ∫èÈ¢òÁöÑÈªòËÆ§ÂÄº
              if (question.type === 'sorting' && (!answer || !(answer as SortingAnswer).order)) {
                answer = { order: [1, 2, 3, 4, 5] };
              }
              
              answers.push({
                user_survey_id: userId,
                question_id: question.id,
                model_id: model.id,
                answer: answer
              });
              
              answerStats[testType.code as keyof typeof answerStats]++;
            }
          });
        }
      }

      logger.info('üìä Á≠îÊ°àÊï∞ÊçÆÂáÜÂ§áÂÆåÊàê', {
        transactionId,
        totalAnswers: answers.length,
        byType: answerStats
      });

      // 5. ÊâπÈáè‰øùÂ≠òÁ≠îÊ°à
      const answersQueryId = databaseLogger.logQueryStart({
        table: 'user_survey_answer',
        operation: 'INSERT',
        data: { count: answers.length }
      });

      const { data: answersData, error: answersError } = await client
        .from('user_survey_answer')
        .insert(answers)
        .select();

      if (answersError || !answersData) {
        databaseLogger.logQueryError(answersQueryId, answersError, Date.now(), {
          table: 'user_survey_answer',
          operation: 'INSERT'
        });
        databaseLogger.logTransaction('rollback', transactionId);
        throw new Error(`‰øùÂ≠òÁ≠îÊ°àÂ§±Ë¥•: ${answersError?.message}`);
      }

      databaseLogger.logQuerySuccess(answersQueryId, answersData, Date.now(), {
        table: 'user_survey_answer',
        operation: 'INSERT'
      });

      // 6. Êèê‰∫§‰∫ãÂä°
      databaseLogger.logTransaction('commit', transactionId);
      const duration = Date.now() - startTime;

      logger.info('‚úÖ Á≠îÊ°àÊèê‰∫§‰∫ãÂä°ÊàêÂäü', {
        transactionId,
        userId,
        totalAnswers: answers.length,
        duration: `${duration}ms`
      });

      // 7. üöÄ Ëá™Âä®Ëß¶ÂèëÂàÜÊûêÔºàÂºÇÊ≠•ÊâßË°åÔºå‰∏çÈòªÂ°ûÂìçÂ∫îÔºâ
      const analysisRequest: AnalysisRequest = {
        userId,
        userInfo: data.userInfo,
        answers: {
          fiveQuestions: data.fiveQuestions,
          mbti: data.mbti,
          bigFive: data.bigFive,
          disc: data.disc,
          holland: data.holland,
          values: data.values
        }
      };

      // ÂºÇÊ≠•ÊâßË°åAIÂ¢ûÂº∫ÂàÜÊûêÔºå‰∏çÁ≠âÂæÖÁªìÊûú
      this.aiAnalysisService.triggerAnalysisAfterSubmission(analysisRequest)
        .then((analysisResult: any) => {
          logger.info('üéØ AIÂ¢ûÂº∫ÂàÜÊûêÂ∑≤ÂÆåÊàê', {
            userId,
            analysisId: analysisResult.id,
            confidenceScore: analysisResult.confidence_score,
            processingTime: analysisResult.processing_time_ms,
            analysisMethod: analysisResult.analysis_method || 'AI-enhanced'
          });
        })
        .catch((error: any) => {
          logger.error('‚ö†Ô∏è AIÂ¢ûÂº∫ÂàÜÊûêÂ§±Ë¥•Ôºà‰∏çÂΩ±ÂìçÁ≠îÊ°àÊèê‰∫§Ôºâ', {
            userId,
            error: {
              name: error instanceof Error ? error.name : 'Unknown',
              message: error instanceof Error ? error.message : String(error)
            }
          });
        });

      // ËøîÂõûÊàêÂäüÂìçÂ∫î
      res.json({
        message: 'ÊµãËØïÁªìÊûú‰øùÂ≠òÊàêÂäüÔºåÂàÜÊûêÊ≠£Âú®ÂêéÂè∞ËøõË°å',
        surveyId: userId,
        stats: {
          totalAnswers: answers.length,
          answersByType: answerStats,
          duration: `${duration}ms`
        },
        analysis: {
          status: 'processing',
          message: 'ÂàÜÊûêÊä•ÂëäÊ≠£Âú®ÁîüÊàê‰∏≠ÔºåËØ∑Á®çÂêéÊü•ÁúãÁªìÊûú'
        }
      });

    } catch (error) {
      const duration = Date.now() - startTime;
      
      // ËÆ∞ÂΩï‰∫ãÂä°Â§±Ë¥•
      databaseLogger.logTransaction('rollback', transactionId);
      
      logger.error('‚ùå Á≠îÊ°àÊèê‰∫§‰∫ãÂä°Â§±Ë¥•', {
        transactionId,
        error: {
          name: error instanceof Error ? error.name : 'Unknown',
          message: error instanceof Error ? error.message : String(error),
          stack: error instanceof Error ? error.stack : undefined
        },
        duration: `${duration}ms`
      });

      res.status(500).json({
        error: error instanceof Error ? error.message : 'Â§ÑÁêÜÊµãËØïÊèê‰∫§Â§±Ë¥•',
        transactionId
      });
    }
  }
} 